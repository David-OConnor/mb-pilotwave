# This file contains functions for setting up and accessing the wave field in the oscillating bath.
# Mostly from MBII.

from functools import partial

import brisk
from scipy import special

from constants import *
import wave_reflection



# @jit
def surface_height(t: float, r: float, v: float) -> float:
    """From MBII. Analytic solution for surface
    height, based on one impact. The results can be added to take into account multiple
    impacts. v is impact velocity. Uses equation 3.7. 3.9 is more accurate, but requires
    numerical evaluation; 3.7 is a good approximate.

    This models only the standing/faraday wave; the transient wave generated by
    a  bounce does not interact with the droplet on subsequent bounces, so we
    can discard it."""

    # The following are numerically derived, found in a table MBI p 645.
    # Use version of 20 cSt 80hz drop for now.

    τ = ω_D * t  # dimensionless time.

    # MBII also includes it as τ_D = (Oh_e * k_C**2) ** -1. Not sure what Oh_e is, so can't compare.
    # todo I think we can approximate Oh_e as just Oh? In that case, this value's wack?
    # Decay time (s), then undimensionalized, of waves without forcing, from JFM (T_D) ther
    τ_D = ω_D * (1 / 54.9)


    # These constants are found in tables in MBII, section A.5.
    k_C__k_F = .971  # ratio of k_C to k_F
    τ_F__τ_D = 1.303


    # I think we can do k_C = k_F: "The critical (most unstable) wavenumber k C is
    # found to be close to the Faraday wavenumber k F , given by the dispersion
    # relation (Benjamin & Ursell 1954): k_F**3 + Bo * k_F = (1/4) * Ω**2.
    # This doesn't come out neatly solving for k_F!. but JFM has an approximation:
    k_F = 1.25  # mm**-1
    k_C = k_F  # k_C is the critical (most unstable) wavenumber.


    # todo what is μe??? Not defined in paper, but used.

    # Ohe is the effective Ohnesorge number. # todo what is mu e??
    # Ohe = μe / (σ*ρ*R0)**(1/2)  # μe / (σρR0)**(1/2)  # or OhD ?'
    μ_e = μ # todo ?
    Oh_e = μ_e / (σ * ρ * R_0) ** (1/2)  # μe / (σρR0)**(1/2)  # or OhD ?

    term1 = (4*sqrt(2*π))/(3*sqrt(τ))  # From eq 3.7
    # term1 = (4 * sqrt(2 * π)) / 3  # From eq 3.9
    term2 = (k_C**2*k_F*Oh_e**(1/2))/(3*k_F**2 + Bo)

    # From eq 3.7
    term4 = cos(Ω * τ / 2) * exp((Γ / Γ_F - 1) * (τ / τ_D)) * brisk.j0(k_C * r)

    # H = partial(special.hankel1, 0)  # todo ??
    # From eq 3.9
    # term4 = H(τ) / sqrt(τ) * exp((Γ / Γ_F - 1) * (τ / τ_D)) * brisk.j0(k_C * r)



    # F is the Dimensionless reaction force acting on the drop.

    # The formula in MBII calls for an integration of F over the contact time;
    # The info clarifying that force can be approximated by a point force doens't
    # explicitly, AFAICT, say how to approximate this point force, but includes
    # this statement about change of momentum; and since integrating momentum over
    # time is force... Can we just use this?

    # "The drop’s change of momentum during impact is at most ΔP ≈ 4/3 * π *
    # ρ * R_0^3 * 2v"

    ΔP = (4 * π / 3) * ρ * R_0**3 * 2 * v
    amplitude = ΔP * sin(Ω/2)



    # print(Γ, Γ_F, τ, τ_D)
    # print((Γ / Γ_F - 1) * (τ / τ_D))
    # print(exp((Γ / Γ_F - 1) * (τ / τ_D)), "2")

    # print(term4, "T4")


    return term1 * term2 * amplitude * term4


# @jit
def height_helper(t: float, impact: Impact, point: Point) -> float:
    """Convenience function to calculate surface height at a point, given an
    impact and time."""
    Δx, Δy = point[0] - impact.x, point[1] - impact.y
    point_dist = (Δx ** 2 + Δy ** 2) ** 0.5
    return surface_height(t, point_dist, impact.F)


def net_surface_height(t: float, impacts_: Iterable, sample_pt: np.ndarray,
                       corral=False, reflectivity=1) -> float:
    """Finds the height under a sample point, taking into account multiple impacts."""

    # This could possibly be jitted by replacing the Impacts list/object with a 2d array.

    # height_below_sample includes the base height from all impacts, and their reflections.
    height_below_sample = 0

    for impact in impacts_:
        # todo MBII describes filtering out an old impact if its amplitude falls below 0.1% of its
        # todo initial value. Consider implementing something similar.

        t_since_impact = t - impact.t  # We care about time since impact.
        # Exclude impacts that occur after, or simulataneously with the current time.
        if t_since_impact <= 0:
            continue

        # Find the the base, ie non-reflected-component height.
        height_below_sample += height_helper(t_since_impact, impact, sample_pt)

        # todo adjustable corral center
        if corral:
            corral_center = np.array([0, 0])
            Δx, Δy = sample_pt[0] - corral_center[0], sample_pt[1] - corral_center[1]
            dist_sample_center = (Δx ** 2 + Δy ** 2) ** 0.5
            # Points outside the circle are 0 for full reflectivity.
            if dist_sample_center > D/2:
                height_below_sample *= 1 - reflectivity
            else:
                # Add reflection adjustment; one reflection currently. Find all points
                # outside the circle that reflect onto our sample point; find their
                # heights, and add to the sample.
                # Convert impact to an array, for faster use with jited funcs.
                for reflection_pt in wave_reflection.find_reflection_points(
                        np.array([impact.x, impact.y]), sample_pt):
                    height_below_sample += height_helper(t_since_impact, impact, reflection_pt) * reflectivity

    return height_below_sample


def surface_height_gradient(t: float, impacts_: Iterable[Impact], x: float, y: float) -> \
        Tuple[float, float]:
    """Create a linear approximation, for finding the slope at a point.
    x and y are points.  t is the time we're taking the derivative.
    Used to calculate bounce mechanics."""
    # todo perhaps you should take into account higher order effects.
    δ = 1e-6  # Arbitrarily small

    height = partial(net_surface_height, t, impacts_)

    # Take a sample on each side of the location we're testing.
    h_x_left = height((x - δ/2, y))
    h_x_right = height((x + δ/2, y))
    h_y_left = height((x, y - δ/2))
    h_y_right = height((x, y + δ/2))

    return (h_x_right - h_x_left) / δ, (h_y_right - h_y_left) / δ


@jit
def impact_force(v: float) -> float:
    # todo superceded by momentum for now. ?
    """Calculate the force imparted by a drop bounce on the bath."""
    # We're transferring momentum from the drop to the bath. ?
    # v is drop speed at impact.

    # JFM; this is given in terms of the component of drag force, but might be
    # what we're looking for.
    C*m*g * sqrt(ρ * R_0 / σ)
    # units: kg * m * s**-2 * sqrt(kg/m^3 * m * m * N**-1)
    # kg * m * s**-2 * sqrt(m**-2 * s**2)  -->   kg * m * s**-2 * m**-1 * s**-1 = kg * s**-3??


    """ From M&B:  The drop’s change
    of momentum during impact is at most 1P ≈ 4/3 * π * ρ * R_0^3 * 2v"""
    ΔP = (4*π / 3) * ρ * R_0**3 * 2*v

