# This file contains functions for setting up and accessing the wave field.
# Mostly from MBII.

from functools import partial

import brisk

from constants import *
from drops import Impact, Point
import wave_reflection


@jit
def surface_height(t: float, r: float, v: float) -> float:
    """From Molacek and Bush 'Drops Walking on a vibrating Bath'. (MBII) Analytic solution for surface
    height, based on one impact. The results can be added to take into account multiple
    impacts. v is impact velocity. Uses equation 3.9.

    This models only the standing/faraday wave; the transient wave generated by
    a  bounce does not interact with the droplet on subsequent bounces, so we
    can discard it."""

    τ = ω_D * t
    # todo what is μe??? Not defined in paper, but used.

    # Ohe is the effective Ohnesorge number. # todo what is mu e??
    # Ohe = μe / (σ*ρ*R0)**(1/2)  # μe / (σρR0)**(1/2)  # or OhD ?'
    μ_e = μ # todo ?
    Oh_e = μ_e / (σ * ρ * R_0) ** (1/2)  # μe / (σρR0)**(1/2)  # or OhD ?

    term1 = (4*sqrt(2*π))/(3*sqrt(τ)) * (k_C**2*k_F*Oh_e**(1/2))/(3*k_F**2 + Bo)

    # F is the Dimensionless reaction force acting on the drop.

    # The formula in MBII calls for an integration of F over the contact time;
    # The info clarifying that force can be approximated by a point force doens't
    # explicitly, AFAICT, say how to approximate this point force, but includes
    # this statement about change of momentum; and since integrating momentum over
    # time is force... Can we just use this?

    # "The drop’s change of momentum during impact is at most ΔP ≈ 4/3 * π *
    # ρ * R_0^3 * 2v"
    ΔP = (4 * π / 3) * ρ * R_0**3 * 2 * v
    amplitude = ΔP * sin(Ω/2)

    term3 = cos(Ω*τ / 2) * exp((Γ / Γ_F - 1) * (τ / τ_D)) * brisk.j0(k_C * r)

    # Note: todo this is a start at the more "complete" version in the paper.
    # term1 = (4*sqrt(τ))/(3) * (k_C**2*kF*Ohe**(1/2))/(3*kF**2 + Bo)
    # term2 =
    # term3 = H(τ)/sqrt(τ) * exp((Γ/ΓF - 1) * (τ/τ_D)) * special.j0(k_C*r)

    return term1 * amplitude * term3


@jit
def height_helper(t: float, impact: Impact, point: Point) -> float:
    """Convenience function to calculate surface height at a point, given an
    impact and time."""
    Δx, Δy = point[0] - impact.x, point[1] - impact.y
    point_dist = (Δx ** 2 + Δy ** 2) ** 0.5
    return surface_height(t, point_dist, impact.F)


def net_surface_height(t: float, impacts_: Iterable, sample_pt: np.ndarray,
                       corral=False, reflectivity=1) -> float:
    """Finds the height under a sample point, taking into account multiple impacts."""
    # todo add a limiter so old impacts aren't included; they're insignificant,
    # todo and we need to computationally limit the num of impacts.
    # This could possibly be jitted by replacing the Impacts list/object with a 2d array.

    # height_below_drop includes the base height from all impacts, and their reflections.
    height_below_sample = 0

    for impact in impacts_:
        t_since_impact = t - impact.t  # We care about time since impact.
        # Exclude impacts that occur after, or simulataneously with the current time.
        if t_since_impact <= 0:
            continue

        # Find the the base, ie non-reflected-component height.
        height_below_sample += height_helper(t_since_impact, impact, sample_pt)

        corral_center = np.array([0, 0])
        # todo adjustable corral center
        if corral:
            Δx, Δy = sample_pt[0] - corral_center[0], sample_pt[1] - corral_center[1]
            dist_sample_center = (Δx ** 2 + Δy ** 2) ** 0.5
            # Points outside the circle are 0 for full reflectivity.
            if dist_sample_center > D/2:
                height_below_sample *= 1 - reflectivity
            else:
                # Add reflection adjustment; one reflection currently. Find all points
                # outside the circle that reflect onto our sample point; find their
                # heights, and add to the sample.
                # Convert impact to an array, for faster use with jited funcs.
                for reflection_pt in wave_reflection.find_reflection_points(
                        np.array([impact.x, impact.y]), sample_pt):
                    height_below_sample += height_helper(t_since_impact, impact, reflection_pt) * reflectivity

    return height_below_sample


def surface_height_gradient(t: float, impacts_: Iterable[Impact], x: float, y: float) -> \
        Tuple[float, float]:
    """Create a linear approximation, for finding the slope at a point.
    x and y are points.  t is the time we're taking the derivative.
    Used to calculate bounce mechanics."""
    # todo perhaps you should take into account higher order effects.
    δ = 1e-6  # Arbitrarily small

    height = partial(net_surface_height, t, impacts_)

    # Take a sample on each side of the location we're testing.
    h_x_left = height((x - δ/2, y))
    h_x_right = height((x + δ/2, y))
    h_y_left = height((x, y - δ/2))
    h_y_right = height((x, y + δ/2))

    return (h_x_right - h_x_left) / δ, (h_y_right - h_y_left) / δ
