from collections import namedtuple
from functools import partial
from typing import Tuple, Iterable

import brisk
import matplotlib.pyplot as plt
import numba
import numpy as np
from numpy import pi as π, sqrt, cos, sin, tan, arctan2, exp, log
from scipy import integrate

from constants import *
from wave_reflection import find_reflection_points
import vertical


jit = numba.jit(nopython=True)

τ = 2 * π


# Assume we're not modeling the up and down motions; each simulation tick
# represents the particle impacting the grid

# todo improved bounce/contact mechanics; tranfer energy to the drop from oscillation, and do more
# todo than a simple reflection.  Find the force of each impact; put into wave height eq.


# MBI / MBII = Malacek and Bush companion papers, 2013
# JFM = A trajectory equation for walking droplets: hydrodynamic pilot-wave theory
# by Anand U. Oza, Rodolfo R. Rosales and John W. M. Bush


# an Impact is an event of the drop hitting the surface.
Impact = namedtuple('Impact', ['t', 'x', 'y', 'F'])  # Add other aspects like speed, force etc.
Point = namedtuple('Point', ['x', 'y'])  # Add other aspects like speed, force etc.

impacts = []


class IntegrationEvent(Exception):
    """Pass the new y value as an argument."""
    pass


@jit
def effective_grav(t:  float) -> float:
    """Effective gravity in bath frame of reference. From MBI; not sure where
    to use it atm."""
    # Gravity plus the fictitious force in the vibrating bath reference frame.
    # I think this is taken care of numerically simply by subtracting bath height
    # when calculating the height below drop. Maybe.
    # Shown as  g*(t)
    return g + γ * sin(τ * f * t)


def effective_grav2(τ_:  float) -> float:
    """Effective gravity in bath frame of reference. From MBI; not sure where
    to use it atm."""
    # Shown as B0*(τ_) in MBI.
    return 1 + Γ * sin(Ω * τ_)


@jit
def drag(v: float):
    """From Molacek and Bush and JFM. The drag force """
    # D is the time-averaged drag coefficient.
    # "The first term arises from the transfer of momentum from the drop to the
    # bath during impact, and the second from the aerodynamic drag exerted on
    # the droplet during flight." - Oza, Rosales and Bush
    D = C*m*g * sqrt(ρ * R_0 / σ) + 6 * π * μ_a * R_0 * (1 + (π * ρ_a * g * R_0) / (6 * μ_a * ω))
    return -D * v


@jit
def impact_force(v: float) -> float:
    # todo superceded by momentum for now. ?
    """Calculate the force imparted by a drop bounce on the bath."""
    # We're transferring momentum from the drop to the bath. ?
    # v is drop speed at impact.

    # JFM; this is given in terms of the component of drag force, but might be
    # what we're looking for.
    C*m*g * sqrt(ρ * R_0 / σ)
    # units: kg * m * s**-2 * sqrt(kg/m^3 * m * m * N**-1)
    # kg * m * s**-2 * sqrt(m**-2 * s**2)  -->   kg * m * s**-2 * m**-1 * s**-1 = kg * s**-3??


    """ From M&B:  The drop’s change
    of momentum during impact is at most 1P ≈ 4/3 * π * ρ * R_0^3 * 2v"""
    ΔP = (2*τ / 3) * ρ * R_0**3 * 2*v


@jit
def surface_height(t: float, r: float, v: float) -> float:
    """From Molacek and Bush 'Drops Walking on a vibrating Bath'. Analytic solution for surface
    height, based on one impact. The results can be added to take into account multiple
    impacts. v is impact velocity

    This models only the standing/faraday wave; the transient wave generated by
    a  bounce does not interact with the droplet on subsequent bounces, so we
    can discard it."""

    τ_ = ω_D * t  # τ_ is dimensionless time, not 2*pi !!
    # todo what is μe??? Not defined in paper, but used.

    # Ohe is the effective Ohnesorge number. # todo what is mu e??
    # Ohe = μe / (σ*ρ*R0)**(1/2)  # μe / (σρR0)**(1/2)  # or OhD ?'
    μ_e = μ # todo ?
    Oh_e = μ_e / (σ * ρ * R_0) ** (1/2)  # μe / (σρR0)**(1/2)  # or OhD ?

    term1 = (4*sqrt(τ))/(3*sqrt(τ_)) * (k_C**2*k_F*Oh_e**(1/2))/(3*k_F**2 + Bo)

    # F is the Dimensionless reaction force acting on the drop.

    # The formula in MBII calls for an integration of F over the contact time;
    # The info clarifying that force can be approximated by a point force doens't
    # explicitly, AFAICT, say how to approximate this point force, but includes
    # this statement about change of momentum; and since integrating momentum over
    # time is force... Can we just use this?

    # "The drop’s change of momentum during impact is at most ΔP ≈ 4/3 * π *
    # ρ * R_0^3 * 2v"
    ΔP = (2 * τ / 3) * ρ * R_0**3 * 2 * v
    amplitude = ΔP * sin(Ω/2)

    term3 = cos(Ω*τ_ / 2) * exp((Γ / Γ_F - 1) * (τ_ / τ_D)) * brisk.j0(k_C * r)

    # Note: todo this is a start at the more "complete" version in the paper.
    # term1 = (4*sqrt(τ))/(3) * (k_C**2*kF*Ohe**(1/2))/(3*kF**2 + Bo)
    # term2 =
    # term3 = H(τ)/sqrt(τ) * exp((Γ/ΓF - 1) * (τ/τ_D)) * special.j0(k_C*r)

    return term1 * amplitude * term3


@jit
def height_helper(t: float, impact: Impact, point: Point) -> float:
    """Convenience function to calculate surface height at a point, given an
    impact and time."""
    Δx, Δy = point[0] - impact.x, point[1] - impact.y
    point_dist = (Δx ** 2 + Δy ** 2) ** 0.5
    return surface_height(t, point_dist, impact.F)


def net_surface_height(t: float, impacts_: Iterable, sample_pt: np.ndarray,
                       corral=False, reflectivity=1) -> float:
    """Finds the height under a sample point, taking into account multiple impacts."""
    # todo add a limiter so old impacts aren't included; they're insignificant,
    # todo and we need to computationally limit the num of impacts.
    # This could possibly be jitted by replacing the Impacts list/object with a 2d array.

    # height_below_drop includes the base height from all impacts, and their reflections.
    height_below_sample = 0

    for impact in impacts_:
        t_since_impact = t - impact.t  # We care about time since impact.
        # Exclude impacts that occur after, or simulataneously with the current time.
        if t_since_impact <= 0:
            continue

        # Find the the base, ie non-reflected-component height.
        height_below_sample += height_helper(t_since_impact, impact, sample_pt)

        corral_center = np.array([0, 0])
        # todo adjustable corral center
        if corral:
            Δx, Δy = sample_pt[0] - corral_center[0], sample_pt[1] - corral_center[1]
            dist_sample_center = (Δx ** 2 + Δy ** 2) ** 0.5
            # Points outside the circle are 0 for full reflectivity.
            if dist_sample_center > D/2:
                height_below_sample *= 1 - reflectivity
            else:
                # Add reflection adjustment; one reflection currently. Find all points
                # outside the circle that reflect onto our sample point; find their
                # heights, and add to the sample.
                # Convert impact to an array, for faster use with jited funcs.
                for reflection_pt in find_reflection_points(np.array([impact.x, impact.y]), sample_pt):
                    height_below_sample += height_helper(t_since_impact, impact, reflection_pt) * reflectivity

    return height_below_sample


def surface_height_gradient(t: float, impacts_: Iterable[Impact], x: float, y: float) -> \
        Tuple[float, float]:
    """Create a linear approximation, for finding the slope at a point.
    x and y are points.  t is the time we're taking the derivative.
    Used to calculate bounce mechanics."""
    # todo perhaps you should take into account higher order effects.
    δ = 1e-6  # Arbitrarily small

    height = partial(net_surface_height, t, impacts_)

    # Take a sample on each side of the location we're testing.
    h_x_left = height((x - δ/2, y))
    h_x_right = height((x + δ/2, y))
    h_y_left = height((x, y - δ/2))
    h_y_right = height((x, y + δ/2))

    return (h_x_right - h_x_left) / δ, (h_y_right - h_y_left) / δ


@jit
def surface_oscilation(t: float) -> Tuple[float, float, float]:
    """Return the surface's height and velocity at time t due to its oscillation;
    a simple harmonic oscillator."""
    # Oscillation starts the cycle at negative amplitude.
    # Use global constants for frequency and bath acceleration.

    bath_accel = γ * cos(ω * t)  # integrate this to get velocity and position.
    bath_vel = γ * ω**-1 * sin(ω * t)  # + C
    bath_height = -γ * ω**(-2) * cos(ω*t)  # + C*t

    return bath_height, bath_vel, bath_accel


# def bounce():
#     # FT is the trangental component of the reaction force.
#     F = 0
#     FT = -F*(δh(X, τ)) / (δX)


# @jit
def bounce_v(grad_x: float, grad_y: float, vx: float, vy: float, vz: float) -> np.ndarray:
    """Calculate the outgoing velocity in x, y, and z directions after a bounce."""
    # todo atm the drop does not lose any momentum to the surface.
    # todo you coulud include bath oscillation velocity here, but may need
    # todo a fininte contact time to do so.
    v = np.array([vx, vy, vz])
    normal = np.cross(np.array([1, 0, grad_x]), np.array([0, 1, grad_y]))
    unit_normal = normal / np.linalg.norm(normal)

    reflection = v - 2*(v @ unit_normal) * unit_normal

    # todo calculate collision kinetic energy? Catchers mit keeps drop from coalescing??

    return reflection


# @jit
def rk4(f, y: Iterable, t: float, h: float, args: Tuple) -> np.ndarray:
    """Basic mechanics of Runge-Kutta 4 ODE"""
    # Convert to arrays to so we can add and multiply element-wise.
    y = np.array(y)

    k1 = np.array(f(y, t, *args)) * h
    k2 = np.array(f(y + k1/2, t + h/2, *args)) * h
    k3 = np.array(f(y + k2/2, t + h/2, *args)) * h
    k4 = np.array(f(y + k3, t + h, *args)) * h
    return y + (k1 + 2*(k2 + k3) + k4) / 6


def rhs(y: np.ndarray, t: np.ndarray) -> Tuple:
    """Right hand integration function, simplified for one drop; no bounce"""
    sx, sy, sz, vx, vy, vz = y

    # # Calculate drag force for accelerations. The z component also includes gravity.
    ax, ay = drag(vx), drag(vy)
    az = drag(vz) - g
    # az = drag(vz) - effective_grav(t) # you could do this too?

    return vx, vy, vz, ax, ay, az


def ode_standalone(t: np.ndarray, corral=False) -> Tuple:
    """Purpose-built, non-general RK4 integrator for modelling multiple drops,
    with events. Events with one drop, or multiple drops with no events work
    with more elegant solutions, like scipy's odeint or the rk4_odeint above."""
    impacts_ = []

    # todo model two separate conditions: drop in flight, and drop in contact
    # todo with surface.

    # initial drop conditions: sx, sy, sz, vx, vy, vz
    # Per MBI, initial conditions play little role in subsequent dynamics.
    drops = np.array([
        [0, 0, 1, .1, .1, 0],
        # [100, 110, 10, 0, 0, 0],
        # [100, 95, 10, 0, 0, 0],
        # [105, 100, 10, 0, 0, 0],
        # [105, 105, 10, 0, 0, 0],
        # [105, 95, 10, 0, 0, 0],
        # [95, 100, 10, 0, 0, 0],
        # [95, 105, 10, 0, 0, 0],
        # [95, 95, 10, 0, 0, 0],

    ])

    # Border format is (x1, y1, x2, y2), ie a line connecting two points.
    borders = [(0, 200, 500, 200)]

    num_drops, drop_len = drops.shape
    # The solution will have three axis: time, which drop, and drop conditions
    # (conditions are position, velocity etc etc)
    soln = np.empty([len(t), num_drops, drop_len])
    soln[0] = drops

    for i in range(len(t) - 1):
        t_ = t[i]  # current  time
        h = t[i + 1] - t[i]  # time step

        for j in range(num_drops):
            drop_conditions = soln[i, j]  # todo ??
            sx, sy, sz, vx, vy, vz = drop_conditions

            # todo code to limit checks for contact, for speed reasons
            # todo put it back to see if it helps
            if sz <= 10 and vz < 0:  # todo lower sz limit.
                sample_pt = np.array([sx, sy])
                # The surface height, compared to a reference avg of 0.
                surface_h_below_drop = net_surface_height(t_, impacts_, sample_pt, corral=corral)

                # Take into account the surface oscillation; it moves the whole
                # surface uniformly.  Also, reference the bottom of the drop
                # rather than the top by shifting down half a radius.
                surface_h_below_drop -= (surface_oscilation(t_)[0] + R_0)

            else:
                surface_h_below_drop = sz - 10  # This means trigger the airborne integrator.


            if sz <= surface_h_below_drop:
                # Model contact period with vertical functions from MBI
                # An impct is detected.


                # Hand off vertical mechanics to a separate integrator.
                τ_start = ω_D * t_



                # grad_x, grad_y = surface_height_gradient(t_, impacts_, sx, sy)
                # # This bounce velocity change overrides the default, of last step's accel.
                #
                # vx_bounce, vy_bounce, vz_bounce = bounce_v(grad_x, grad_y,
                #                                            vx, vy, vz)
                #
                # # todo here, or in bounce_v, goes the force imparted on the drop:
                # # todo −mg∇h(x_p, t) horizontal force??
                #
                # # todo what next?
                # bath_v_start = surface_oscilation(t_)[1]
                # bath_v_end = surface_oscilation(t_ + T_C)[1]
                #
                # bath_a_start = surface_oscilation(t_)[2]
                # bath_a_end = surface_oscilation(t_ + T_C)[2]
                #
                # # todo is it this simple? add the bath velocity at the end of
                # # todo the bounce. Can't be, since it's net is 0; we need to add
                # # todo energy.
                # # vz_bounce += bath_v_end
                #
                # v = sqrt(vx ** 2 + vy ** 2 + vz ** 2)
                # impacts_.append(Impact(t_, sx, sy, v))
                #
                # # Overwrite the prev-calculated non-bounce integration with
                # # these calculated values.
                # y_drop = sx, sy, sz, vx_bounce, vy_bounce, vz_bounce



            else:
                # Model using a simple airborne kinematics integrator.

                # Integrate the drop's motion through the air.
                y_drop = rk4(rhs, drop_conditions, t_, h, args=())  # no bounce


            soln[i+1, j] = y_drop

    return soln, impacts_


def plot_trajectories(soln: np.ndarray):
    n_drops = soln.shape[1]

    for drop_i in range(n_drops):
        plt.plot(soln[:, drop_i, 0], soln[:, drop_i, 1])

    plt.show()


def quickplot(t: np.ndarray):
    soln, impacts = ode_standalone(t)
    plot_trajectories(soln)
